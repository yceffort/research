---
title: "RAG 그것이 알고 싶다"
marp: true
paginate: true
theme: default
tags:
  - AI
  - LLM
  - RAG
date: 2025-07-03
description: "진짜로 알고 싶다"
published: true
---

# 실무에서 만드는 RAG

## Pie Bot 사례로 보는 실전 구현

> 프론트엔드 개발자가 직접 만든 진짜 RAG 시스템  
> github.com/NaverPayDev/bot

<!-- _class: invert -->

@yceffort

---

## RAG가 뭘까?

> **R**etrieval-**A**ugmented **G**eneration  
> 검색으로 보강된 생성

쉽게 말해: **필요한 정보를 찾아서 + LLM에게 참고하게 해주는 기술**

---

## Pie Bot으로 예를 들면

```ts
// 일반 LLM: "hidash가 뭐야?"
❌ "죄송합니다. hidash에 대한 정보가 없습니다."

// Pie Bot (RAG): "hidash가 뭐야?"
✅ "@naverpay/hidash는 throttle, debounce 함수를 포함한 유틸리티 라이브러리입니다"
   + 실제 코드 예시와 문서 링크 포함
```

핵심: **우리의 코드를 LLM이 알 수 있게 만드는 기술**

---

## 왜 RAG가 필요한가요?

### LLM의 근본적인 한계

- **지식 단절**

  > ChatGPT: "2023년까지만 알아요"
  > → 최신 코드나 변경사항 반영 불가

- **사내 정보 접근 불가**

  > 회사 API, 컨벤션, 프로젝트 구조 등 모름

- **환각(Hallucination)**

  > 모르는 걸 모른다고 하면 되지 그럴듯하게 말함

---

## 그래서 등장한 RAG

> 검색으로 보강된 생성이라는 뜻

1. 검색 (Retrieval) - 40%
2. 증강 (Augmentation) - 30%
3. 생성 (Generation) - 30%

> 각 단계에 대해서 하나씩 파해쳐봅시다!

---

## 1단계: 검색

> 질문과 코드 모두를 **벡터화**하여 **의미적으로 유사한 코드**를 찾아냄

### 검색 단계의 핵심: 임베딩

→ 질문도 코드도 **숫자 벡터**로 변환해야 컴퓨터가 그 의미를 비교할 수 있음

---

## 임베딩이란?

> 텍스트를 **컴퓨터가 이해할 수 있는 숫자 배열**로 바꾸는 과정

```ts
"throttle"
→ [0.23, -0.15, 0.87, 0.42, ...]
```

→ 이제 컴퓨터가 의미적으로 유사한 것끼리 비교 가능함

---

## 임베딩 예시로 이해하기

### 텍스트가 숫자로 변환되는 과정

```
"throttle 함수"    → [0.23, -0.15, 0.87, 0.42, ...]
"debounce 메서드"  → [0.21, -0.14, 0.85, 0.41, ...]
"사과"            → [0.98,  0.42, -0.33, -0.51, ...]
```

### 핵심: 숫자가 비슷하면 = 의미가 비슷함

- throttle ↔ debounce: 거의 같은 숫자들 → **유사도 높음** ✅
- throttle ↔ 사과: 완전 다른 숫자들 → **관련 없음** ❌

---

## 벡터 유사도를 쉽게 이해하기

### 1️⃣ 벡터 = 숫자들의 리스트

```
throttle: [0.23, -0.15, 0.87]
debounce: [0.21, -0.14, 0.85]
```

### 2️⃣ 유사도 = 얼마나 비슷한가?

- 각 위치의 숫자들이 비슷하면 → 의미도 비슷함
- 0.23 ≈ 0.21, -0.15 ≈ -0.14, 0.87 ≈ 0.85

### 3️⃣ 실무에서는 이렇게 계산

```ts
const similarity = cosineSimilarity(vec1, vec2);
// 0~1 사이 값: 1에 가까울수록 유사
```

---

## 2단계 전제: 코드 청킹

> 너무 큰 파일은 검색 정확도를 떨어뜨림  
> → 의미 있는 단위로 **나누는 과정** 필요

---

## 청킹: Before vs After

### ❌ Before: 파일 전체를 하나로

```
utils.ts (3000줄) → 하나의 거대한 벡터
```

→ "이 파일 어딘가에 있긴 한데..." 수준

### ✅ After: 함수 단위로 분리

```
throttle 함수 (30줄) → 작은 벡터
debounce 함수 (25줄) → 작은 벡터
isEmpty 함수 (15줄) → 작은 벡터
```

→ "정확히 throttle 함수입니다!" 수준

---

## 실제 예시: 청크 데이터 구조

```json
{
  "repository": "@naverpay/pie",
  "filePath": "packages/utils/throttle.js",
  "symbol": "throttle",
  "content": "const throttle = (func, wait = 0, {...",
  "vector": [0.03831027, 0.018387219, ...]
}
```

- 모든 코드를 함수/클래스 단위로 청킹하여 data/naverpay_embeddings.json 파일로 저장
- 저장소명, 파일경로, 심볼(함수/클래스명) 등 메타데이터 포함

---

## 벡터 검색의 실제

```ts
// 1. 사용자 질문을 벡터로 변환
const queryVector = await generateEmbedding(userQuery);

// 2. 가장 유사한 코드 15개 찾기
const top15 = vectorIndex.search(queryVector, 15);

// 3. 추가로 정확도 높이기 (휴리스틱)
const reranked = applyHeuristics(top15, userQuery);
```

---

## 휴리스틱 기반 재정렬

> 단순 벡터 유사도만으로는 부족함 → 실무 규칙 추가

```ts
// 가산점
+ 파일명에 키워드 포함 (+0.15)
+ 함수명에 키워드 포함 (+0.10)
+ index.ts 파일 (+0.20)

// 감점
- test 파일 (-0.40)
- mock 파일 (-0.30)
```

💡 왜? `throttle` 검색 시 테스트 코드보다 실제 구현체를 원하니까!

---

## 2단계: 증강 (Augmentation)

> 찾은 코드만 던져주면 LLM이 제대로 답변 못함  
> → **맥락(Context)을 풍부하게 만들어주는 과정**

---

## 증강이 중요한 이유

### ❌ 맥락 없이 질문만

```
"throttle 써줘"
```

→ LLM: "어떤 throttle? 어디에? 어떻게?"

### ✅ 맥락과 함께

```
현재 파일: Button.tsx
현재 코드: <Button onClick={handleClick} />
찾은 정보: @naverpay/pie의 throttle 함수
요청사항: throttle 적용
```

→ LLM: "아, Button의 onClick에 throttle을 적용하는구나!"

---

## 프롬프트 엔지니어링의 핵심

### 1️⃣ 역할 정의

```
당신은 Pie Bot입니다.
자바스크립트/타입스크립트 전문가로서...
```

### 2️⃣ 현재 상황 전달

```
파일: src/components/Button.tsx
주변 코드: const handleClick = () => {...}
```

### 3️⃣ 참고 자료 제공

```
사용 가능한 함수: throttle from '@naverpay/pie'
함수 시그니처: throttle(func, wait, options)
```

---

## 컨텍스트 윈도우 관리

> LLM은 한 번에 처리할 수 있는 텍스트 길이에 제한이 있음

### 우선순위에 따른 정보 구성

1. **필수**: 사용자 질문, 현재 코드
2. **중요**: 찾은 함수 정의, 사용 예시
3. **보조**: 관련 문서, 추가 팁

### 전략

- 찾은 코드 15개 중 상위 3개만 상세히 포함
- 나머지는 요약하거나 생략
- 전체 토큰을 8000개 이내로 관리

---

## 실제 프롬프트 구성 예시

```typescript
// 시스템 프롬프트
`당신은 Pie Bot입니다. 사내 코드 전문가로서 도움을 제공합니다.

현재 상황:
- 파일: ${editorFilePath}
- 코드: ${targetCode}

참고 자료:
${top3Results.map((r) => r.content).join("\n")}

지침:
1. 작동하는 코드로 답변
2. 필요한 import 명시
3. 한국어로 설명`;

// 사용자 메시지
userQuery: "이 버튼에 throttle 적용해줘";
```

---

## 3단계: 생성 (Generation)

> 준비된 프롬프트로 LLM이 최종 답변을 생성

---

## 생성 단계의 핵심 요소

### 1️⃣ 모델 선택 및 설정

```ts
const model = genAI.getGenerativeModel({
  model: "gemini-1.5-pro-latest",
  safetySettings: [
    {
      category: HarmCategory.HARM_CATEGORY_HARASSMENT,
      threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    },
    // ... 다른 안전 설정들
  ],
});
```

### 2️⃣ 현재 사용 중인 모델

- 텍스트 생성: `gemini-1.5-pro-latest`
- 임베딩: `embedding-001`

---

## 응답 생성 과정

<style scoped>section { font-size: 22px; }</style>

### 1️⃣ 대화형 세션 관리

```ts
const chat = generativeModel.startChat({
  history: conversationHistory,
  generationConfig: { maxOutputTokens: 8192 },
});
const result = await chat.sendMessage(promptForThisTurn);
```

### 2️⃣ 웹뷰로 결과 전달

```ts
// VSCode 웹뷰 패널에 결과 표시
webviewPanel.webview.postMessage({
  type: "botResponse",
  content: result.response.text(),
});
```

### 3️⃣ 후속 질문 지원

- 대화 히스토리를 유지하여 문맥 기반 대화 가능
- 이전 답변을 참고한 추가 질문 처리

---

## 실전 팁: 환각(Hallucination) 방지

### 문제: LLM이 없는 함수를 만들어냄

```ts
// LLM이 상상으로 만든 코드
import { superThrottle } from "@naverpay/pie"; // 없는 함수!
```

### 해결책: 명시적 제약

```ts
프롬프트에 추가:
"다음 함수만 사용 가능합니다: ${availableFunctions.join(', ')}"
"존재하지 않는 함수를 import하지 마세요"
"불확실한 경우 '찾을 수 없습니다'라고 답변하세요"
```

---

## 정리: Pie Bot으로 보는 실전 RAG 구현

---

### RAG 3단계 균형있는 구성

| 단계    | 비중 | 핵심 포인트                         |
| ------- | ---- | ----------------------------------- |
| 🔍 검색 | 40%  | 임베딩 + 벡터 검색 + 휴리스틱       |
| 🧩 증강 | 30%  | 컨텍스트 구성 + 프롬프트 엔지니어링 |
| 🤖 생성 | 30%  | LLM 활용 + 품질 관리 + 최적화       |

각 단계가 균형있게 중요함!

---

### Pie Bot의 차별화 포인트

- ✅ **개발 워크플로우 통합**: 에디터 내에서 바로 사용
- ✅ **사내 코드 특화**: 우리 회사 컨벤션과 패키지 이해
- ✅ **실용적 접근**: 완벽보다는 "지금 당장 쓸 수 있는" 도구
- ✅ **점진적 개선**: JSON → Vector DB로 진화 가능한 구조

---

### Pie Bot처럼 시작하려면?

1. **작게 시작하기**: 특정 패키지나 유틸부터
2. **빠른 피드백**: 일단 배포하고 개선
3. **기존 도구 활용**: Vector DB 없이 JSON으로도 가능
4. **사용자 중심**: 개발자가 진짜 원하는 것에 집중

---

## Pie Bot의 다음 목표

### 1️⃣ 더 똑똑하게

- **Vector DB 도입**: 대용량 코드베이스도 빠르게 검색
- **의미 단위 청킹**: 클래스, 모듈 단위로 더 정교하게

### 2️⃣ 더 편하게

- **IDE 깊은 통합**: 자동완성처럼 자연스럽게
- **대화 히스토리**: 이전 질문 이어서 하기

### 3️⃣ 더 안전하게

- **멀티 LLM 지원**: Gemini, Claude, GPT 중 선택
- **기업 보안 강화**: 민감 정보 필터링

---

## 지금까지 결론

- Pie Bot은 단순한 "LLM 붙인 챗봇"이 아니라  
  → **개발 워크플로우에 깊이 통합되는 RAG 기반 도구**로 진화시키고 싶다!

- 검색 정확도, 생성 품질, 사용자 편의성, 확장성 모두 고려한 **장기적 기술 투자 로드맵**

> 더이상 금융서비스에 있다는 이유로 AI를 미룰 수 없다...!

---

## Pie Bot을 왜 만들어야 할까?

---

- 지금까지 공통 유틸과 갖가지 cli 도구를 잘만들어도, 전파에는 한계가 있다는 것을 느낌
  → 존재를 몰라서 못 쓰고, 문서도 안 보고, 다른 유틸 이미 쓰고, 그걸 다시 pie로 홍보하고 하지만 이미 다른 코드로 배포되어 있는 아쉬운 상황
- 이건 검색/문서의 문제가 아니라  
  → **개발자가 작성하는 맥락 내 추천과 연결의 문제**라는 생각

---

- Pie Bot은 단순한 챗봇이 아니라  
  → **개발자의 흐름 속에서 유틸을 "찾아서 쓰게" 만드는 시스템**
- "문서"가 아닌 "도움"을 제공하려면  
  → 코드 작성 시점에, 커서 근처에서, IDE 내부에서 작동해야 함

---

- 이건 결국 LLM, RAG, 인터페이스, 컨텍스트 설계가 모두 필요한 구조고  
  → 이걸 만들 수 있는 곳은 공통개발TF
- 앞으로 유틸이든 컴포넌트든  
  → **검색 가능하고 연결 가능한 형태로 만들어지지 않으면 쓰이지 않을 것**
- 물론 추천보다 중요한 것은 완성도 있는 컴포넌트와 유틸을 만드는 것
  → 디자인시스템 + pie 가 모두 RAG로 제공되면, 개발자들은 보다 더 로직에 집중하여 생산성이 향상되지 않을까?

---

## Pie의 다음 구조: 역할 분리로 진화하기

---

## 역할을 크게 두 개로 분리

> 역할에 따라 명확히 분리하여 **더 빠르고, 정교하게, 안정적으로**

| 팀     | 주요 책임 영역                                   |
| ------ | ------------------------------------------------ |
| 🔍 RAG | 임베딩 생성, 벡터 검색, 청킹 전략, 휴리스틱 정제 |
| 🧠 MCP | 컨텍스트 스키마 설계, 대화 흐름 관리, IDE 연동   |

> 물론 컴포넌트/유틸/재사용가능한 개발자 도구를 만드는 것도 우리의 몫

---

## 왜 나누어야 할까?

- 관심사가 완전히 다름  
  → 검색 품질 vs. 문맥 유지
- 개선 루프를 독립적으로 운영 가능
- 역할이 명확해야 **개선도 명확해짐**

---

## 장기적으로는 이렇게 확장

- **RAG** → pie, 디자인 시스템이 만든 코드를 이해할 수 있도록 확장
- **MCP** → 다양한 LLM 도구에 붙일 수 있는 통합 context API 레이어로 확장
- Pie Bot은 단순 챗봇이 아니라, → **LLM이 코드를 이해하게 만드는 시스템**
- 이를 위해 **RAG와 MCP, 두 분야가 함께 진화**

---

## 미래의 프론트엔드 개발자의 역할?

- 단순히 "컴포넌트를 잘 보여주는" 것이 아니라
- **잘 추천되도록 설계하고, 검색 가능하게 만드는 것**이 목적

---

## 앞으로 우리가 만들어야 할 구조는?

| 목표                   | 구현 방식                                           |
| ---------------------- | --------------------------------------------------- |
| 재사용 가능한 컴포넌트 | 디자인 시스템 + 유틸 라이브러리 구조 정비           |
| 검색 가능한 컴포넌트   | 의미 단위 청킹, 적절한 메타데이터, 문서 일관성 유지 |
| 추천 가능한 컴포넌트   | 휴리스틱 최적화, 사용 예시 제공, 컨텍스트 정제      |

---

## 결국 이렇게 정리됩니다

> **“컴포넌트를 잘 설계하고, 완벽하게 개발하며, 그것을 검색 가능하고, 재사용 가능하게 RAG/MCP 구조로 포장하는 것”**

→ 이것이 앞으로의 프론트엔드 개발자가 가져야 할 핵심 역량이 아닐까..?

---

## 서비스 개발은 어떻게 바뀔까?

---

## 지금의 개발 흐름

- 필요한 유틸이나 컴포넌트를 **직접 기억하거나 검색**
- 문서를 찾아보거나, 동료에게 물어봄
- 반복 구현, 중복 코드, 비효율적인 전파
- LLM 도구는 있지만 **문맥을 이해하지 못함**

---

## RAG + MCP가 완성되면?

- 지금 코드의 **문맥을 LLM이 이해**
- 필요한 유틸/컴포넌트를 **의미적으로 추천**
- 문서, 예시, import 경로까지 **자동 삽입**
- → 개발자는 **“무엇을 하고 싶은지”만 말하면 됨**
- 단, LLM은 실수할 수 있으므로 **실제로 코드의 의미를 이해하고 검토할 역량은 더 중요**
  - 이건 진짜 중요!! (코딩테스트의 교훈)

---

## 아마도 미래는...?

| 항목            | 지금                          | RAG + MCP 이후                       |
| --------------- | ----------------------------- | ------------------------------------ |
| 유틸 사용       | 기억하거나 검색               | 커서 기반 자동 추천                  |
| 문서 확인       | oss.fin, storybook, wiki 열람 | 관련 내용이 자동 컨텍스트로 제공됨   |
| 코드 작성       | 직접 작성                     | 핵심만 작성 → 나머지는 자동 scaffold |
| 리팩터링        | 경험에 의존                   | 코드 흐름 기반 자동 제안             |
| 컴포넌트 재사용 | 기억하지 않으면 못 씀         | 유사 맥락에서 자동 추천              |

---

## 실전 예시로 보면

### 지금은

- “이벤트 핸들러에 throttle 써야지”
- pie에 throttle 있는지 기억 → 검색 → 문서 확인
- import 경로 추측 → 적용 → 타입 오류 수정

### 이후에는

- "클릭 너무 자주 일어나는데 막고 싶어" 라고만 말함
- Pie Bot이 코드 맥락 + 주변 코드 분석
- → `@naverpay/pie/throttle` 추천 + 사용 예시 + import까지 제공

---

## 핵심 변화

> **“코드를 외워서 쓰던 시대”에서 → “의도와 맥락으로 코드를 설계하고 전달하는 시대”로”**

- LLM은 도우미일 뿐  
  → **정확한 문맥과 구조를 설계하는 개발자**가 여전히 핵심
- 단순 구현보다, **어떤 코드를 왜, 언제, 어떻게 써야 하는지**를 판단하는 능력이 중요

---

## 앞으로 중요한 개발자는?

> “코드를 많이 아는 사람”보다 **“코드를 구조로 설명하고 연결할 수 있는 사람”**

- 의미 단위 청킹
- 유틸 구조화
- 메타데이터 설계
- 문맥 흐름 정의  
  → **LLM이 신뢰할 수 있는 정보 구조를 설계할 수 있는 사람**

---

## 마지막으로, 개발자는 더 중요해진다

- 자동화는 **좋은 설계자가 있을 때만** 잘 동작
- 프론트엔드 개발자는 이제:
  - 컴포넌트를 설계하고
  - 맥락을 구조화하며
  - LLM이 의존할 수밖에 없는 문맥을 만드는 사람

> 자동화는 반복적인 구현을 줄이고, 구조와 문맥을 더 잘 설계할 수 있는 시간을 만들기

---

## 질문 환영합니다! 🙋‍♂️

github.com/NaverPayDev/bot  
@yceffort
